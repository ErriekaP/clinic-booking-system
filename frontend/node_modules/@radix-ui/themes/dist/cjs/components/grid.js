"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Grid = void 0;
const tslib_1 = require("tslib");
const React = tslib_1.__importStar(require("react"));
const classnames_1 = tslib_1.__importDefault(require("classnames"));
const slot_1 = require("./slot");
const grid_props_1 = require("./grid.props");
const helpers_1 = require("../helpers");
const Grid = React.forwardRef((props, forwardedRef) => {
    const { rest: marginRest, ...marginProps } = (0, helpers_1.extractMarginProps)(props);
    const { rest: layoutRest, ...layoutProps } = (0, helpers_1.extractLayoutProps)(marginRest);
    const { className, asChild, display = grid_props_1.gridPropDefs.display.default, columns = grid_props_1.gridPropDefs.columns.default, rows = grid_props_1.gridPropDefs.rows.default, flow = grid_props_1.gridPropDefs.flow.default, align = grid_props_1.gridPropDefs.align.default, justify = grid_props_1.gridPropDefs.justify.default, gap = grid_props_1.gridPropDefs.gap.default, gapX = grid_props_1.gridPropDefs.gapX.default, gapY = grid_props_1.gridPropDefs.gapY.default, style: propStyle, ...gridProps } = layoutRest;
    const Comp = asChild ? slot_1.Slot : 'div';
    let style = {
        ...propStyle,
    };
    if (typeof columns === 'string') {
        style = {
            '--grid-template-columns-initial': parseGridValue(columns),
            ...style,
        };
    }
    if (typeof rows === 'string') {
        style = {
            '--grid-template-rows-initial': parseGridValue(rows),
            ...style,
        };
    }
    if ((0, helpers_1.isBreakpointsObject)(columns)) {
        for (const breakpoint in columns) {
            if ((0, helpers_1.hasOwnProperty)(columns, breakpoint)) {
                const customProperty = `--grid-template-columns-${breakpoint}`;
                style = {
                    [customProperty]: parseGridValue(columns[breakpoint]),
                    ...style,
                };
            }
        }
    }
    if ((0, helpers_1.isBreakpointsObject)(rows)) {
        for (const breakpoint in rows) {
            if ((0, helpers_1.hasOwnProperty)(rows, breakpoint)) {
                const customProperty = `--grid-template-rows-${breakpoint}`;
                style = {
                    [customProperty]: parseGridValue(rows[breakpoint]),
                    ...style,
                };
            }
        }
    }
    return (React.createElement(Comp, { ...gridProps, ref: forwardedRef, className: (0, classnames_1.default)('rt-Grid', className, (0, helpers_1.withBreakpoints)(display, 'rt-r-display'), (0, helpers_1.withBreakpoints)(flow, 'rt-r-gaf'), (0, helpers_1.withBreakpoints)(align, 'rt-r-ai'), (0, helpers_1.withBreakpoints)(justify, 'rt-r-jc', { between: 'space-between' }), (0, helpers_1.withBreakpoints)(gap, 'rt-r-gap'), (0, helpers_1.withBreakpoints)(gapX, 'rt-r-cg'), (0, helpers_1.withBreakpoints)(gapY, 'rt-r-rg'), (0, helpers_1.withLayoutProps)(layoutProps), (0, helpers_1.withMarginProps)(marginProps)), style: Object.keys(style).length ? style : undefined }));
});
exports.Grid = Grid;
Grid.displayName = 'Grid';
function parseGridValue(value) {
    return (value === null || value === void 0 ? void 0 : value.match(/^\d+$/)) ? `repeat(${value}, minmax(0, 1fr))` : value;
}
//# sourceMappingURL=grid.js.map