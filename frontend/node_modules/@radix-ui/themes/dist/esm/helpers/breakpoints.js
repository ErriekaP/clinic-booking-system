/**
 * A helper to generate CSS classes that include breakpoints.
 *
 * Examples:
 * ```
 * const marginTop = '1'
 * withBreakpoints(marginTop, 'mt') // returns 'mt-1'
 *
 * const padding = { initial: '1', xs: '2', md: '3' }
 * withBreakpoints(padding, 'p') // returns 'p-1 xs:p-1 md:p-3'
 *
 * const justifyContent = { initial: 'start', md: 'space-between' }
 * withBreakpoints(justifyContent, 'jc', { 'space-between': 'sb' }) // returns 'jc-start md:jc-sb'
 * ```
 */
function withBreakpoints(value, // Value to check
classPrefix = '', // CSS class prefix, e.g. "px" in "px-1" class
valueMap // Optionally, an object to map prop values to a different CSS suffix
) {
    var _a, _b, _c, _d;
    const classes = [];
    if (typeof value === 'object') {
        for (const bp of Object.keys(value)) {
            if (bp in value) {
                const str = (_a = value[bp]) === null || _a === void 0 ? void 0 : _a.toString();
                const isNegative = str === null || str === void 0 ? void 0 : str.startsWith('-');
                const delimiter = classPrefix === '' ? '' : '-';
                const prefix = isNegative ? `-${classPrefix}` : classPrefix;
                const matchedValue = isNegative ? str === null || str === void 0 ? void 0 : str.substring(1) : str;
                if (matchedValue === undefined) {
                    continue;
                }
                const suffix = (_b = valueMap === null || valueMap === void 0 ? void 0 : valueMap[matchedValue]) !== null && _b !== void 0 ? _b : matchedValue;
                const className = bp === 'initial'
                    ? `${prefix}${delimiter}${suffix}`
                    : `${bp}:${prefix}${delimiter}${suffix}`;
                classes.push(className);
            }
        }
    }
    if (typeof value === 'string') {
        const isNegative = value.startsWith('-');
        const delimiter = classPrefix === '' ? '' : '-';
        const prefix = isNegative ? `-${classPrefix}` : classPrefix;
        const matchedValue = isNegative ? value.substring(1) : value;
        const suffix = (_c = valueMap === null || valueMap === void 0 ? void 0 : valueMap[matchedValue]) !== null && _c !== void 0 ? _c : matchedValue;
        classes.push(`${prefix}${delimiter}${suffix}`);
    }
    if (typeof value === 'boolean') {
        const delimiter = classPrefix === '' ? '' : '-';
        const matchedValue = value.toString();
        const suffix = (_d = valueMap === null || valueMap === void 0 ? void 0 : valueMap[matchedValue]) !== null && _d !== void 0 ? _d : matchedValue;
        classes.push(`${classPrefix}${delimiter}${suffix}`);
    }
    return classes.join(' ');
}
function isBreakpointsObject(obj) {
    return typeof obj === 'object';
}
export { withBreakpoints, isBreakpointsObject };
//# sourceMappingURL=breakpoints.js.map