'use client';
import * as React from 'react';
import classNames from 'classnames';
import * as TooltipPrimitive from '@radix-ui/react-tooltip';
import { DirectionProvider } from '@radix-ui/react-direction';
import { Slot } from '@radix-ui/react-slot';
import { themePropDefs, getMatchingGrayColor } from './theme-options';
const noop = () => { };
const ThemeContext = React.createContext(undefined);
function useThemeContext() {
    const context = React.useContext(ThemeContext);
    if (context === undefined) {
        throw new Error('`useThemeContext` must be used within a `Theme`');
    }
    return context;
}
const Theme = React.forwardRef((props, forwardedRef) => {
    const context = React.useContext(ThemeContext);
    const isRoot = context === undefined;
    if (isRoot) {
        return (React.createElement(TooltipPrimitive.Provider, null,
            React.createElement(DirectionProvider, { dir: "ltr" },
                React.createElement(ThemeRoot, { ...props, ref: forwardedRef }))));
    }
    return React.createElement(ThemeImpl, { ...props, ref: forwardedRef });
});
Theme.displayName = 'Theme';
const ThemeRoot = React.forwardRef((props, forwardedRef) => {
    const { appearance: appearanceProp = themePropDefs.appearance.default, accentColor: accentColorProp = themePropDefs.accentColor.default, grayColor: grayColorProp = themePropDefs.grayColor.default, panelBackground: panelBackgroundProp = themePropDefs.panelBackground.default, radius: radiusProp = themePropDefs.radius.default, scaling: scalingProp = themePropDefs.scaling.default, hasBackground = themePropDefs.hasBackground.default, ...rootProps } = props;
    const [appearance, setAppearance] = React.useState(appearanceProp);
    React.useEffect(() => setAppearance(appearanceProp), [appearanceProp]);
    const [accentColor, setAccentColor] = React.useState(accentColorProp);
    React.useEffect(() => setAccentColor(accentColorProp), [accentColorProp]);
    const [grayColor, setGrayColor] = React.useState(grayColorProp);
    React.useEffect(() => setGrayColor(grayColorProp), [grayColorProp]);
    const [panelBackground, setPanelBackground] = React.useState(panelBackgroundProp);
    React.useEffect(() => setPanelBackground(panelBackgroundProp), [panelBackgroundProp]);
    const [radius, setRadius] = React.useState(radiusProp);
    React.useEffect(() => setRadius(radiusProp), [radiusProp]);
    const [scaling, setScaling] = React.useState(scalingProp);
    React.useEffect(() => setScaling(scalingProp), [scalingProp]);
    // Initial appearance on page load when `appearance` is explicitly set to `light` or `dark`
    const ExplicitRootAppearanceScript = React.memo(({ appearance }) => (React.createElement("script", { dangerouslySetInnerHTML: {
            __html: `!(function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');d.style.colorScheme='${appearance}';c.add('${appearance}');}catch(e){}})();`,
        } })), () => true // Never re-render
    );
    ExplicitRootAppearanceScript.displayName = 'ExplicitRootAppearanceScript';
    // Client-side only changes when `appearance` prop is changed while developing
    React.useEffect(() => updateThemeAppearanceClass(appearanceProp), [appearanceProp]);
    const resolvedGrayColor = grayColor === 'auto' ? getMatchingGrayColor(accentColor) : grayColor;
    return (React.createElement(React.Fragment, null,
        appearance !== 'inherit' && React.createElement(ExplicitRootAppearanceScript, { appearance: appearance }),
        hasBackground && (React.createElement("style", { dangerouslySetInnerHTML: {
                __html: `
:root, .light, .light-theme { --color-page-background: white; }
.dark, .dark-theme { --color-page-background: var(--${resolvedGrayColor}-1); }
body { background-color: var(--color-page-background); }
`,
            } })),
        React.createElement(ThemeImpl, { ...rootProps, ref: forwardedRef, isRoot: true, hasBackground: hasBackground, 
            //
            appearance: appearance, accentColor: accentColor, grayColor: grayColor, panelBackground: panelBackground, radius: radius, scaling: scaling, 
            //
            onAppearanceChange: setAppearance, onAccentColorChange: setAccentColor, onGrayColorChange: setGrayColor, onPanelBackgroundChange: setPanelBackground, onRadiusChange: setRadius, onScalingChange: setScaling })));
});
ThemeRoot.displayName = 'ThemeRoot';
const ThemeImpl = React.forwardRef((props, forwardedRef) => {
    var _a, _b, _c, _d, _e, _f;
    const context = React.useContext(ThemeContext);
    const { asChild, isRoot, hasBackground, 
    //
    appearance = (_a = context === null || context === void 0 ? void 0 : context.appearance) !== null && _a !== void 0 ? _a : themePropDefs.appearance.default, accentColor = (_b = context === null || context === void 0 ? void 0 : context.accentColor) !== null && _b !== void 0 ? _b : themePropDefs.accentColor.default, grayColor = (_c = context === null || context === void 0 ? void 0 : context.resolvedGrayColor) !== null && _c !== void 0 ? _c : themePropDefs.grayColor.default, panelBackground = (_d = context === null || context === void 0 ? void 0 : context.panelBackground) !== null && _d !== void 0 ? _d : themePropDefs.panelBackground.default, radius = (_e = context === null || context === void 0 ? void 0 : context.radius) !== null && _e !== void 0 ? _e : themePropDefs.radius.default, scaling = (_f = context === null || context === void 0 ? void 0 : context.scaling) !== null && _f !== void 0 ? _f : themePropDefs.scaling.default, 
    //
    onAppearanceChange = noop, onAccentColorChange = noop, onGrayColorChange = noop, onPanelBackgroundChange = noop, onRadiusChange = noop, onScalingChange = noop, 
    //
    ...themeProps } = props;
    const Comp = asChild ? Slot : 'div';
    const resolvedGrayColor = grayColor === 'auto' ? getMatchingGrayColor(accentColor) : grayColor;
    const isExplicitAppearance = props.appearance !== undefined && props.appearance !== 'inherit';
    const isExplicitGrayColor = props.grayColor !== undefined;
    const shouldHaveBackground = !isRoot &&
        (hasBackground === true ||
            (hasBackground !== false && (isExplicitAppearance || isExplicitGrayColor)));
    return (React.createElement(ThemeContext.Provider, { value: React.useMemo(() => ({
            appearance,
            accentColor,
            grayColor,
            resolvedGrayColor,
            panelBackground,
            radius,
            scaling,
            //
            onAppearanceChange,
            onAccentColorChange,
            onGrayColorChange,
            onPanelBackgroundChange,
            onRadiusChange,
            onScalingChange,
        }), [
            appearance,
            accentColor,
            grayColor,
            resolvedGrayColor,
            panelBackground,
            radius,
            scaling,
            //
            onAppearanceChange,
            onAccentColorChange,
            onGrayColorChange,
            onPanelBackgroundChange,
            onRadiusChange,
            onScalingChange,
        ]) },
        React.createElement(Comp, { "data-is-root-theme": isRoot ? 'true' : 'false', "data-accent-color": accentColor, "data-gray-color": resolvedGrayColor, "data-has-background": shouldHaveBackground ? 'true' : 'false', "data-panel-background": panelBackground, "data-radius": radius, "data-scaling": scaling, ref: forwardedRef, ...themeProps, className: classNames('radix-themes', {
                // Only apply theme class to nested `Theme` sections.
                //
                // If it's the root `Theme`, we either rely on
                // - something else setting the theme class when root `appearance` is `inherit`
                // - our script setting it when root `appearance` is explicit
                light: !isRoot && appearance === 'light',
                dark: !isRoot && appearance === 'dark',
            }, themeProps.className) })));
});
ThemeImpl.displayName = 'ThemeImpl';
function updateThemeAppearanceClass(appearance) {
    if (appearance === 'inherit')
        return;
    const root = document.documentElement;
    if (root.classList.contains('light-theme') || root.classList.contains('dark-theme')) {
        root.classList.remove('light-theme', 'dark-theme');
        root.style.colorScheme = appearance;
        root.classList.add(`${appearance}-theme`);
    }
    if (root.classList.contains('light') || root.classList.contains('dark')) {
        root.classList.remove('light', 'dark');
        root.style.colorScheme = appearance;
        root.classList.add(appearance);
    }
}
export { Theme, useThemeContext, updateThemeAppearanceClass };
//# sourceMappingURL=theme.js.map